# 시간 복잡도란?

- **입력값(N)에 따라 연산량이 얼마나 증가하는지**를 나타내는 개념
- 예를 들어,
  - 알고리즘 A의 연산량이 `O(N)` 이라면, N이 30일 때 30번 수행
  - 알고리즘 B의 연산량이 `O(N²)` 이라면, N이 30일 때 900번 수행
- 입력값이 증가해도 **연산량이 적게 증가하는 알고리즘**이 좋은 알고리즘

<br />

## 최댓값 찾기 알고리즘 분석

> Q. 다음과 같이 숫자로 이루어진 배열이 있을 때, 이 배열 내에서 가장 큰 수를 반환하시오.

### 첫 번째 방법, `O(N²)`

```js
function solution(array) {
  for (let i = 0; i < array.length; i++) {
    let isMaxNum = true;

    for (let j = 0; j < array.length; j++) {
      if (array[i] < array[j]) {
        isMaxNum = false;
      }
    }

    if (isMaxNum) {
      return array[i];
    }
  }
}

console.log('정답 = 6 / 현재 풀이 값 =', solution([3, 5, 6, 1, 2, 4]));
console.log('정답 = 6 / 현재 풀이 값 =', solution([6, 6, 6]));
console.log('정답 = 1888 / 현재 풀이 값 =', solution([6, 9, 2, 7, 1888]));
```

시간 복잡도 분석

- 각 숫자에 대해 모든 숫자와 비교 → 이중 반복문 `O(N²)`
- 정확한 연산량: `2 × N² + N`
- 입력값이 클수록 연산량이 급격히 증가 ❌

<br />

### 두 번째 방법, `O(N)`

```js
function solution(array) {
  let maxNumber = Number.MIN_SAFE_INTEGER;

  for (const number of array) {
    if (maxNumber < number) maxNumber = number;
  }

  return maxNumber;
}

console.log('정답 = 6 / 현재 풀이 값 =', solution([3, 5, 6, 1, 2, 4]));
console.log('정답 = 6 / 현재 풀이 값 =', solution([6, 6, 6]));
console.log('정답 = 1888 / 현재 풀이 값 =', solution([6, 9, 2, 7, 1888]));
```

시간 복잡도 분석

- 배열을 한 번만 순회하면서 비교 → `O(N)`
- 정확한 연산량: `2N + 1`
- 입력값이 커져도 연산량 증가가 완만함 ✅

<br />

## 알고리즘 비교 및 핵심 정리

| 입력값(N) | `O(N²)` (첫 번째 방법) | `O(N)` (두 번째 방법) |
| --------- | ---------------------- | --------------------- |
| 10        | 200                    | 21                    |
| 100       | 20,100                 | 201                   |
| 1,000     | 2,002,000              | 2,001                 |

- `O(N²)` vs `O(N)`: 입력값이 커질수록 연산량 차이가 크게 벌어짐
- 핵심 원칙
  1. <b>지수(N², N³)</b>는 작은 차이도 큰 영향을 줌
  1. <b>상수(2N, 3N)</b>는 무시 가능 → 주요 지수만 고려하면 됨
  1. `O(N)` 알고리즘이 `O(N²)`보다 항상 유리하진 않지만, N이 클수록 차이가 커짐

<br />

## 결론

- `O(N²)` 알고리즘은 큰 입력값에서 비효율적이므로, 가능하면 `O(N)` 이하로 최적화해야 한다
- 시간 복잡도는 입력 크기가 증가할 때 연산량이 어떻게 변화하는지를 분석하는 것이 핵심이다
- 좋은 알고리즘을 설계하려면 연산량이 급격히 증가하지 않도록 고려해야 한다
